<h2 id="jvm-java-virtual-machine">JVM (Java Virtual Machine)</h2>
<blockquote>
<p>JVM이란 가상의 컴퓨터 인데 <strong>자바 광공인 가상의 컴퓨터</strong> </p>
</blockquote>
<ul>
<li>JDK(Java Development Kit): 자바 개발 도구, 즉 현실세계에서는 소프트웨어개발도구 </li>
<li>JRE(Java Runtime Environment): 자바 실행 환경, 즉 운영체제(OS)</li>
<li>JVM(Java Virtual Machine): 자바 가상 기계, 즉 물리적 컴퓨터인 하드웨어 </li>
</ul>
<p>자바 개발 도구인 JDK를 이용해 개발된 프로그램은 JRE에 의해 가상의 컴퓨터인 JVM 상에서 구동된다. </p>
<h3 id="jdk-kre-jvm">JDK, KRE, JVM</h3>
<ul>
<li>JDK: 자바 소스 컴파일러인 javac.exe를 포함</li>
<li>JRE: 자바 프로그램 실행기인 java.exe를 포함</li>
</ul>
<p>이유: 자바 개발자의 플랫폼(하드웨어와 OS의 조합)에 설치된 JVM용으로 프로그램을 작성하고 배포하면 <strong>JVM이 중재자 역할</strong>을 하며 프로그램이 구동되는데 문제가 없게끔 만들어 주고자</p>
<h2 id="프로그램이-메모리를-사용하는-방식---모든-언어">프로그램이 메모리를 사용하는 방식 - 모든 언어</h2>
<p>기계어를 포함한 모든 프로그래밍 언어는, 메모리를 <strong>코드 실행 영역과 데이터 저장 영역</strong>으로 나눠서 사용한다. </p>
<ul>
<li>코드 실행 영역 </li>
<li>데이터 저장 영역 </li>
</ul>
<h2 id="객체지향-프로그램이-메모리를-사용하는-방식">객체지향 프로그램이 메모리를 사용하는 방식</h2>
<p>이제 객체지향 프로그램에서는 데이터 저장 영역을 다시 세 개의 영역으로 나눠서 사용한다. 
이를 간단히 T 메모리 구조라 지칭 <del>(나는 F)</del> </p>
<ul>
<li>코드 실행 영역</li>
<li>데이터 저장 영역 <ul>
<li>스태틱(static) 영역 - 클래스 영역</li>
<li>스택(stack) 영역 - 메서드 영역</li>
<li>힙(heap) 영역 - 객체 영역 </li>
</ul>
</li>
</ul>
<h2 id="자바에서-볼-수-있는-절차적구조적-프로그래밍">자바에서 볼 수 있는 절차적/구조적 프로그래밍</h2>
<p>객제지향 프로그래밍은 절차적/구조적 프로그래밍과 함께 한다. (같은 개념이라는 뜻 아님) </p>
<ul>
<li>절차적 프로그래밍: 명령어라 순서대로 실행되며 한 번에 하나의 작업만 가능하다.</li>
<li>구조적 프로그래밍: 절차적 프로그래밍의 하위 개념으로 goto문을 없애거나 goto문에 대한 의존성을 줄여준 것으로 대표적임. </li>
</ul>
<h3 id="절차적-프로그래밍---goto-불매">절차적 프로그래밍 - goto 불매</h3>
<p><strong>절차적 프로그래밍은 goto를 쓰지 말라는 것이다.</strong> 그렇기에 자바에서는 goto를 사용하지 못 하도록 예약어로 걸어두었다.</p>
<p>goto가 뭐길래.. goto는 지정된 라벨을 프로그램 제어를 통해 전송할 수 있다. 
프로그램이 실행되다가 goto문을 만나면 지정된 라벨로 점프하는 것이다. 이러한 goto 문을 쓰지 말라는 이유는 프로그램의 실행 순서가 이해하기 힘들어지기 때문이다. </p>
<h3 id="구조적-프로그래밍---함수-지향">구조적 프로그래밍 - 함수 지향</h3>
<p><strong>구조적 프로그래밍은 함수를 쓰자는 것이다.</strong> 함수를 사용하면 중복 코드를 한 곳에 모아서 관리할 수 있고, 함수 단위로 분리해 이해하기 좋은 코드로 작성할 수 있다는 장점이 있다. </p>
<h3 id="자바에서-볼-수-있는-이들의-유산">자바에서 볼 수 있는 이들의 유산</h3>
<p>이러한 절차적/구조적 프로그래밍의 유산은 <strong>메서드</strong>에서 볼 수 있다. </p>
<ul>
<li>goto문: 제어 흐름을 왔다갔다 하게 함. </li>
<li>함수: 중복 코드 제거 및 논리 분할 </li>
</ul>
<p>객제지향에서의 함수는 메서드이다. 그렇기에 이들의 유산은 메서드에서 확인할 수 있다. 객제지향 언어에서 제어문이 존재할 수 있는 유일한 곳이 메서드 내부이기 때문이다. </p>
<h4 id="함수-vs-메서드">함수 vs 메서드</h4>
<p>이들은 같으나, 절차적/구조적에서 함수라 불러서 객체지향에서 메서드라 부르는 것이다. 
굳이 차이점을 뽑자면 ... 함수는 클래스와 아무 관계 없지만 메서드는 반드시 클래스 내에 존재해야 하는 것이다. </p>
<h1 id="예제로-보는-t-메모리-구조">예제로 보는 T 메모리 구조</h1>
<h2 id="1-다시-보는-main-메서드-메서드-스택-프레임">1. 다시 보는 main() 메서드: 메서드 스택 프레임</h2>
<p>이러한 코드가 있을 때 한 줄 단위로 메모리에 어떤 변화가 생기는지 보겠다. </p>
<pre><code>public class Start {
    public static void main(String[] args) {
        System.out.println(&quot;Hello OOP!!!&quot;);
    }
}</code></pre><h3 id="스태틱-프레임">스태틱 프레임</h3>
<h4 id="main-메서드가-실행되기-전에-jvm에서-수행하는-전처리-작업들">main 메서드가 실행되기 전에 JVM에서 수행하는 전처리 작업들</h4>
<blockquote>
<ol>
<li>java.lang 패키지를 T 메모리의 스태틱 영역에 배치한다. </li>
<li>import 된 패치키를 T 메모리의 스태틱 영역에 배치한다. </li>
<li>프로그램 상의 모든 클래스를 T 메모리의 스태틱 영역에 배치한다. </li>
</ol>
</blockquote>
<p>JRE는 먼저 main()메서드가 있는지 확인하고 존재가 확인되면 JVM에 전원을 넣어 부팅을 한다. 
이제 부팅된 JVM이 위의 전처리 작업들을 수행하는 것이다. </p>
<h3 id="스택-프레임">스택 프레임</h3>
<p>main() 메서드가 실행되기 위해 새롭게 스택 프레임에 자리를 잡는다. </p>
<ul>
<li>클래스 정의를 시작하는 것을 제외한 여는 중괄호({)가 생길 때마다 스택 프레임이 하나씩 생긴다. </li>
<li>같은 맥락으로 닫는 중괄호(})로 스택 프레임이 소멸된다. </li>
</ul>
<h4 id="메서드-인자-args">메서드 인자 args</h4>
<p>main() 메서드의 인자인 args 를 저장할 변수 공간을 스택 프레임의 맨 밑에 확보해야 한다. 즉 메서드 인자들의 변수 공간을 할당하는 과정이 필요하다. </p>
<p>그림과 같은 구조를 보이고 나서야 main() 메서드의 첫 명령을 실행한다. </p>
<p><img alt="" src="https://velog.velcdn.com/images/leegarden/post/520cd756-ee6f-4947-83f4-f2088a5a6147/image.png" /></p>
<h3 id="프로그램의-종료">프로그램의 종료</h3>
<p>main() 메서드로 프로그램이 시작된 것과 같이 main() 메서드의 닫는 중괄호로 인해 스택 프레임이 소멸되면서 프로그램은 종료된다. </p>
<p>main() 메서드가 끝나면 JRE는 JVM을 종료하고 JRE 자체도 운영체제 상의 메모리에서 사라진다. 이렇게 되면 JRE 자체도 운영체제 상의 메모리에서 사라지고, 위에서 보인 T 메모리도 사라지게 된다. </p>
<h2 id="2-변수와-메모리-변수-너-어디-있니">2. 변수와 메모리: 변수! 너 어디 있니?</h2>
<p>소제목 진짜 열받는다 </p>
<pre><code>public class Start2 {
    public static void main(String[] args) {
        int i;
        i = 10;

        double d = 20.0;
    }
}</code></pre><p>위의 코드에서는 화면에 보이는 명령문만 있었다면 이제는 변수라는 게 생긴다. 
물론 메인 메서드 내에서의 변수이기 때문에 args 와 같은 위치에 변수 i와 d가 초기화 값을 가진 상태로 메모리에 할당되고, 종료된다. </p>
<p><img alt="" src="https://velog.velcdn.com/images/leegarden/post/dac389e5-0aaa-4942-8558-547b97615500/image.png" /></p>
<h2 id="3-블록-구문과-메모리-블록-스택-프레임">3. 블록 구문과 메모리: 블록 스택 프레임</h2>
<pre><code>public class Start3 {
    public static void main(String[] args) {
        int i = 10;
        int k = 20;

        if(i == 10) {
            int m = k + 5;
            k = m;
        } else {
            int p = k + 10;
            k = p;
        }

        //k = m + p;
    }
}</code></pre><p>if문 전까지의 변수 선언 상황의 메모리 구조는 위의 그림과 같다. </p>
<p>그러나 if문이 시작됨과 동시에 분기를 일으키고 코드를 보면 true가 반환된다. </p>
<blockquote>
<p>그리고 { 를 만났기에 스택 프레임이 시작되는데, 메서드의 스택 프레임이 아니라 if(true) 블록의 스택 프레임이 main() 스택 프레임 안에 중접되어 생성된다. </p>
</blockquote>
<p>그리고 m이란 변수는 if 블록 밖에 있지만 메서드 스택 프레임 안에 있는 k의 값에 5를 더한 게 초기화 값으로 지정되면 할당된다. </p>
<p>메모리 구조는 아래와 같다. </p>
<p><img alt="" src="https://velog.velcdn.com/images/leegarden/post/959b9af0-377c-4964-a05c-7e2263b2ef02/image.png" /></p>
<p>(그림에서 static 영역 잘못됨 square 없어야 함) </p>
<p>그리고 이후에 } 를 만나면서 if(true) 블록의 스택 프레임이 소멸된다. 
이게 k = m + p; 코드가 주석처리 되어 있는 이유다. </p>
<p>이제 메모리 상에서 변수 m과 p는 없는 것이기에 컴파일러 에러가 발생한다. 
이를 통해 변수의 메모리 생존기간(?)을 알 수 있었다. </p>
<h2 id="4-지역-변수와-메모리-스택-프레임에-갇혔어요">4. 지역 변수와 메모리: 스택 프레임에 갇혔어요!</h2>
<blockquote>
<p>내부 스택 프레임에서 외부 스택 프레임의 변수에 접근하는 것은 가능하나 그 역은 불가능하다.</p>
</blockquote>
<p>Q 변수! 너 어디 있니?
A 메모리요 </p>
<p>변수는 스태틱, 스택, 힙 세 군데 모두에 존재한다. 
그러나 각각의 변수는 다른 목적을 갖기에 이름도 클래스 멤버 변수, 지역 변수, 객체 멤버 변수이다. </p>
<ul>
<li>클래스 멤버 변수: <strong>스태틱 영역에서 일생을 보낸다</strong>. 스태틱 영역에 한 번 자리를 잡으면 JVM 이 종료될 때까지 고정된(static) 상태로 그 자리를 지킨다. a.k.a 안방마님</li>
<li>지역 변수: 스택 영역에서 일생을 보내는데 <strong>스택 프레임 영역 안에서 일생을 보낸다</strong>. 따라서 스택 프레임이 사라지면 변수도 함께 사라진다. 그렇기에 내부 외부 어쩌가고 중요한 것이다. <ul>
<li>스택 메모리 내의 스택 프레임 안의 변수를 지역 변수라 하는 이유이다. 그 지역(스택 프레임)에서만 사용할 수 있고 외부에서는 사용할 수 없기 때문이다. 
또한 그 지역이 사라지면 지역 변수도 메모리에서 함께 사라진다. </li>
</ul>
</li>
<li>객체 멤버 변수: 힙에서 일생을 보낸다. 이들은 객체와 함께 가비지 컬렉터라고 하는 힙 메모리 회수기에 의해 일생을 마치게 된다. </li>
</ul>
<h2 id="5-메서드-호출과-메모리-메서드-스택-프레임2">5. 메서드 호출과 메모리: 메서드 스택 프레임2</h2>
<pre><code>public class Start4 {
    public static void main(String[] args) {
        int k = 5;
        int m;

        m = square(k);
    }

    private static int square(int k) {
        int result;

        k = 25;

        result = k;

        return result;
    }
}</code></pre><p>main() 메서드에서 k는 초기화 값이 있지만 m은 쓰레기 값으로 선언되고 이후에 square 메서드를 통해 값이 지정된다. </p>
<p>이를 전제로 하면 m이 선언만 됐을 때에는 메모리 구조에서 main 메서드의 스택 프레임만 있었을 텐데, m이 square 메서드를 통해 값이 할당되면서 해당 메서드가 선언된 9번째 줄로 이동한다. </p>
<p>square 메서드에서 인자 값인 k에 25를 넣지 않았을 때의 구조는 아래와 같다. </p>
<p><img alt="" src="https://velog.velcdn.com/images/leegarden/post/deedc0c0-e29a-405e-980a-d410b6aafb86/image.png" /></p>
<p>이후에 코드가 실행되며 k에 25를 넣게 되고 result에도 k 값을 대입하게 되며 값들이 25로 변경되기는 한다.
물론 메서드에서 result를 return 하기에 반환값 또한 25로 복사된다. </p>
<p>그리고 square() 메서드의 } 가 실행되면서 해당 메서드의 스텍 프레임은 스택 메모리에서 사라지지만, 반환값이 있었기에 m에 반환을 하며 사라진다. </p>
<blockquote>
<p>중요한 건 square() 메서드에서의 k와 main()메서드에서의 k는 전혀 다른 변수라는 것이다.
이를 <strong>Call By Value(값에 의한 호출)</strong> 이라고 한다. </p>
</blockquote>
<p>그렇기에 square() 메서드의 k에 아무런 변화를 줘도 main()의 k는 쭉 5일 것이다. </p>
<h3 id="왜-두-메서드는-서로의-값에-접근을-하지-못-할까">왜 두 메서드는 서로의 값에 접근을 하지 못 할까?</h3>
<ul>
<li>메서드 블랙박스화: 입력 값들을 반환값에 의해서만 메서드 사이에 전달될 뿐 서로 내부의 지역 변수를 볼 수 없는 것을 의미.</li>
</ul>
<p>해당 코드가 진행되는 메모리 구조를 생각해 보면 어느 순간에도 두 메서드는 서로의 값에 접근할 수 없다. 두 메서드의 메모리 내서에서의 생존 기간이 엇갈리기 때문이다. </p>
<p>물론 square() 메서드가 실행될 때에는 main() 메서드와 동시에 있지만, main() 메서드의 지역 변수에는 참조할 수 없다. </p>
<p>책에서 짐작하는 이유는 아래와 같다. </p>
<h4 id="첫-째-이치에-맞기-때문이다">첫 째, 이치에 맞기 때문이다.</h4>
<p>메서드는 서로의 고유 공간인데, 침범하면 무단 침입으로 자바 월드에.. 문제를 유발할 수 있기 때문이다. </p>
<h4 id="둘-째-포인터-문제-때문이다">둘 째, 포인터 문제 때문이다.</h4>
<p>한 대상의 지역 변수에 접근하려면 그 변수의 위치를 명확하게 알아야 하는데, 그러기 위해서는 포인터(메모리 주소 값)를 알아야 한다. </p>
<blockquote>
<p>자바는 NO Pointer 이다. </p>
</blockquote>
<h4 id="셋-째-여러-메서드에서-서로-호출을-할-경우-꼬인다">셋 째, 여러 메서드에서 서로 호출을 할 경우 꼬인다.</h4>
<p>위와 같은 맥락으로, 실제로는 다양한 메서드에서 서로 호출하고 값을 반환받는다. 이런 모든 상황에서 변수에 접근을 허용하면 포인터라른 개념이 필요로 되기에 언어 스펙상 메서드 스택 프레임 사이에 변수를 참조하는 것은 불가능하다. </p>
<blockquote>
<p>*<em>그렇기에 메서드를 호출하면서 인자로 전달되는 것은 변수 자체가 아니라 변수가 저장한 값만을 복사해서 전달한다. =&gt; Call By Value *</em></p>
</blockquote>
<p>따라서 여러 메서드에서 A라는 메서드를 같이 써도 각각의 메서드에 반환되는 값이 다른 것이다. 
이는 메서드의 변수 자체를 주는 게 아니라 그 상황에 변수가 저정한 값의 복사본을 반환값으로 건네 주었기 때문이다. </p>
<h2 id="6-전역-변수와-메모리-전역-변수-쓰지-말라니까요">6. 전역 변수와 메모리: 전역 변수 쓰지 말라니까요!</h2>
<blockquote>
<p>전역 변수는 피할 수 있는한 피하자 </p>
</blockquote>
<p>메서드들 사이에서 값을 전달하는 방법으로 1. 호출시 메서드의 인자를 이용 2. 반환값을 통해 넘겨주기 방법이 있다. 
그러나 전역 변수를 사용해서도 값 전달이 가능하다. </p>
<pre><code>public class Start5 {
    static int share;

    public static void main(String[] args) {
        share = 55;

        int k = fun(5, 7);

        System.out.println(share);
    }

    private static int fun(int m, int p) {
        share = m + p;

        return m - p;
    }
}</code></pre><p>위 코드에서 main() 메서드 이전에 static 으로 선언된 share 변수를 볼 수 있는데 이를 전역 변수라 한다. </p>
<p>이 share 변수가 메모리 구조에서 어떻게 변화하는지 시간 순서대로 정리해 보았다. </p>
<ul>
<li>처음 main() 메서드에서 선언된 값: 55</li>
<li>fun() 메서드를 통해 변경된 값: 12</li>
<li>그러나 fun() 에서 반환된 값: -2</li>
<li>또 그러나 화면에 출력된 share 값: 12</li>
</ul>
<p>이렇게 짧은 코드에서 share로 추측되는 값이 55, 12, -2로 세 개나 된다.
물론 -2는 논외라 할 수 있지만, share를 추측하는 데에 헷갈리게 하면 헷갈렸지 도움을 주진 않았다. </p>
<p>또한 이러한 전역 변수는 static으로 선언됐기에 스택 메모리 영역에 있는 것이 아니라, 스태틱 메모리 영역에 할당된다. 
즉, share를 가져오려면 스태틱 메모리 영역에서 가져와야 한다는 의미이다. </p>
<p>그러나 이러한 전역 변수도 읽기 전용으로 전역 상수로는 이로운 역할을 한다. 
이를 테면 PI와 같이 값이 정해져 수정하지 않는 경우 전역 변수로 사용하기에 좋다. </p>
<blockquote>
<p>정리하자면, 전역 변수의 무분별한 사용은 지양하되 전역 상수로서의 사용은 지향해도 된다. 
이유: 값을 추측하기에 많은 과정이 필요하고 메모리 저장 영역이 다르다. 가장 큰 이유로는 번거롭다. </p>
</blockquote>
<h1 id="멀티-스레드--멀티-프로세스의-이해">멀티 스레드 / 멀티 프로세스의 이해</h1>
<ul>
<li>멀티 스레드(Multi Thread): 멀티 스레드의 T 메모리 모델은 스택 영역을 스레드 개수만큼 분할해서 쓰는 것이다. </li>
</ul>
<p><img alt="" src="https://velog.velcdn.com/images/leegarden/post/9ba9d5d5-8ef4-4e93-895f-8b83687fd747/image.png" /></p>
<ul>
<li>멀티 프로세스(Multi Process): 다수의 데이터 영역 즉 다수의 T 메모리를 갖는 구조이다. </li>
</ul>
<p><img alt="" src="https://velog.velcdn.com/images/leegarden/post/93422de3-3150-4e7d-be8a-bb8657b4c18b/image.png" /></p>
<h2 id="멀티-스레드-vs-멀티-프로세스">멀티 스레드 VS 멀티 프로세스</h2>
<h3 id="1-메모리-공유-정도의-차이">1. 메모리 공유 정도의 차이</h3>
<ul>
<li>멀티 스레드: 하나의 T 메모리만 사용하며 스택 영역만 분할해서 사용하는 구조</li>
<li>멀티 프로세스: 각 프로세스마다 각자의 T 메모리가 있고 각자 고유의 공간을 사용하는 구조 </li>
</ul>
<p>멀티 스레드의 경우, 하나의 T 메모리 안에서 스택 영역만 분할한 것이기에 하나의 스레드에서 다른 스레드의 영역에는 접근할 수 없다. 그러나 스태틱 영역과 힙 영역은 공유해서 사용하는 구조이다. </p>
<p>멀티 프로세스의 경우, 하나의 프로세스가 다른 프로세스의 T 메모리 영역을 절대 침범할 수 없는 메모리 구조이다. </p>
<blockquote>
<p>그렇기에 메모리 사용량은 당연히 멀티 프로세스가 멀티 스레드 대비 크다. </p>
</blockquote>
<h3 id="2-servelet이-cgi-보다-효율적인-이유">2. Servelet이 CGI 보다 효율적인 이유</h3>
<p>Servelet은 요청당 프로세스가 아닌 요청당 스레드를 생성한다. 요청당 프로세스를 생성하는 것은 CGI이다. </p>
<p>위의 내용을 통해 멀티 스레드가 메모리 사용량이 더 적은 것을 확인할 수 있기에 Servelet이 CGI보다 효율적이라는 것을 알 수 있다. </p>
<h3 id="3-멀티-스레드에서-전역-변수-사용의-문제점">3. 멀티 스레드에서 전역 변수 사용의 문제점</h3>
<p>간단한 예시로, 두 개의 스레드로 구성된 프로그램이 있다. </p>
<ol>
<li>스레드1이 공유 영역(스태틱과 힙)에 있는 전역 변수 A에 10을 할당</li>
<li>CPU 사용권이 스레드2로 넘어감</li>
<li>스레드2가 전역 변수 A에 20을 할당</li>
<li>다시 CPU 사용권이 스레드1로 넘어감 </li>
<li>스레드1은 A의 값을 출력하려고 하지만, 스레드1의 입장에서는 갑자기 A의 값이 20으로 출력되는 황당한 상황</li>
</ol>
<p>이와 같이 공유 자원을 사용하면 서로 상황이 다른 문제가 생긴다. 
물론 lock을 걸면 되지만 그럴 거면 멀티 스레드를 왜 씀?
이런 문제가 생기기에 깔끔하게 전역 변수 사용을 지양하는 것이 좋다. </p>
<h3 id="4-예제를-통해-멀티-스레드-경험하기">4. 예제를 통해 멀티 스레드 경험하기</h3>
<p>해당 코드는 멀티 스레드를 사용한 코드이다. </p>
<pre><code>public class Start6 extends Thread {
    static int share;

    public static void main(String[] args) {
        Start6 t1 = new Start6();
        Start6 t2 = new Start6();

        t1.start();
        t2.start();
    }

    public void run() {
        for (int count = 0; count &lt; 10; count++) {
            System.out.println(share++);

            try {
                sleep(10000);
            } catch (InterruptedException e) {
            }
        }
    }
}
</code></pre><p>코드만 봤을 때 전역 변수 사용의 문제점을 한 번에 알아보기 힘들지만 이 코드를 실행시켜보면 위에서 말한 문제를 눈으로 볼 수 있다. 
(예제의 sleep 조건보다 10배 크게 했다.)</p>
<p>예상 결과로는 0부터 9까지 순서대로 나올 것 같지만, 실제 결과는 아래와 같이 0부터 13까지의 숫자가 뒤죽박죽으로 나온다. </p>
<p><img alt="" src="https://velog.velcdn.com/images/leegarden/post/b1bc216e-6b2b-418c-a769-dd0cadb5af1e/image.png" /></p>
<p>이는 위에서 말한 공유 자원의 문제로 0이었다가 ++를 하지만 멀티 스레드이기에 자원 공유로 인해 이렇게.. 시작이 0도 아니고 1로 하는 이상한 결과가 출력된다. </p>
<p>이렇게 값이 서로 변경할 때마다 각 스레드의 입장에서는 이를 모른다는 문제가 있다. </p>
<h1 id="chap-02를-마무리-하며">chap 02를 마무리 하며</h1>
<p>chap 02를 읽으며 키워드라 느낀 단어들은 아래와 같다. </p>
<h4 id="jvm-jre-jdk">JVM, JRE, JDK</h4>
<h4 id="t-메모리-구조">T 메모리 구조</h4>
<h4 id="스태틱-클래스의-놀이터-스택-메서드의-놀이터-힙-객체의-놀이터">스태틱: 클래스의 놀이터, 스택: 메서드의 놀이터, 힙: 객체의 놀이터</h4>
<h4 id="전역-변수">전역 변수</h4>
<p>객제 지향 언어에 국한되지 않고 대부분 언어의 메모리 사용 방식을 알 수 있었으며 코드가 실행될 때 메모리 안에서의 변화를 알 수 있었다. </p>
<ul>
<li>JVM, JRE, JDK: 순서대로 자바 컴퓨터, 자바 컴퓨터 전용 OS, 자바 개발 도구 </li>
<li>T 메모리 구조: 프로그램은 메모리를 코드 실행 영역과 데이터 저장 영역으로 나눠서 사용한다. 여기 데이터 저장 영역에서 스태틱, 스택, 힙 영역으로 또 나뉘며 이 구조가 T 모양과 같아서 T 메모리 구조라 부른다. <ul>
<li>스태틱 메모리 영역: 클래스의 놀이터이며, static으로 선언한 변수나 메서드들이 위치하며 main() 메서드가 실행되기 전 JVM에서 수행되는 전처리 작업들이 진행되는 공간이다. </li>
<li>스택 메모리 영역: 메서드의 놀이터이며, 메서드 별로 스택 프레임 영역이 할당되고 이번 챕터에서 가장 많이 언급됐던 영역이다. 각 메서드 별로는 접근이 안 되기에(아예 불가능은 아니지만 암튼) 메서드 인자나 반환값을 통해 서로 값을 복사해서 전달한다. </li>
<li>힙 메모리 영역: 객체의 놀이터인데 이번 챕터에선 안 다룸. </li>
</ul>
</li>
<li>전역 변수: 아묻따 지양하자. 웬만하면 지양하자. 전역 변수 = 지양<ul>
<li>이유: 전역 변수는 스태틱 영역에 저장된다. 즉 메서드에서의 영역과 다르기에 값을 가져오기 번거롭다. 그리고 모든 메서드에서 접근이 가능하기에 (공유 자원) 값이 수시로 바뀌며 값을 예측하기가 힘들다. 물론 값을 지정해 PI와 같이 전역 상수로 사용하는 것은 권장한다. 
또한, 멀티 스레드의 상황에서 전역 변수는 각 스레드에서의 공유 자원이기에 값이 통일이 안 되고 바껴 문제를 발생시킨다. </li>
</ul>
</li>
</ul>
<p>.
.
.
읽고 정리하는 데에 일주일이 넘게 걸렸지만 꽤나 재밌었고 유익했다고 생각한다. 
이 책을 작년에 읽었음 더 좋았을 텐데라는 생각도 들지만,, 지금이라도 읽은 게 어디인가 ! </p>
<blockquote>
<p>이미지 출처
<a href="https://medium.com/@sammierosado/understanding-the-jvm-java-virtual-machine-b70f73311237">https://medium.com/@sammierosado/understanding-the-jvm-java-virtual-machine-b70f73311237</a>
<a href="https://s-y-130.tistory.com/258">https://s-y-130.tistory.com/258</a>
<a href="https://velog.io/@leeeeeyeon/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0">https://velog.io/@leeeeeyeon/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0</a>
<a href="https://juneyr.dev/java-things">https://juneyr.dev/java-things</a></p>
</blockquote>